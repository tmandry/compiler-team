<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design meeting on Rust Lang - Compiler Team</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/</link><description>Recent content in Design meeting on Rust Lang - Compiler Team</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://rust-lang.github.io/compiler-team/minutes/design-meeting/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-01-streaming-dep-graph-proposal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-01-streaming-dep-graph-proposal/</guid><description>&amp;ldquo;Streaming dep graph&amp;rdquo; proposal Summary of the proposal Currently, incremental compilation begins by loading the old dependency graph and then &amp;ndash; as execution proceeds &amp;ndash; building a new dependency graph in memory. At the end of compilation, this new graph is written out.
PR #60035 proposes to change how the new graph is handled. Instead of building the graph in memory and writing it out at the end, we &amp;ldquo;stream&amp;rdquo; out a series of changes to the dep-graph as we go.</description></item><item><title>2019-12-06 end-to-end query PRs</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-06-end-to-end-query-PRs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-06-end-to-end-query-PRs/</guid><description>Design Meeting 2019-12-06 &amp;ndash; librustc_interface queries Links Zulip topic of the discussion Compiler team issue Pre-design meeting Zulip topic Internals thread with descriptions of PRs Background Goal is end-to-end queries Benefits: Simpler overall model Incremental extending back to parsing mw has done measurements suggesting that on larger crates some 40% of the compilation time comes from Parallel compilation would be more effective, if done on the basis of queries Agenda Tough to frame:) Most important question to settle is what overall stategy we plan to take Do we want to try and land / rebase these PRs?</description></item><item><title>2019-12-20 major changes process</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-20-major-change-process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-20-major-change-process/</guid><description>Major Change Process Zulip thread Summary We want some kind of system where people advertise changes that they are making or plan to make and the team can give high-level feedback early and &amp;ndash; if we decide to go with the change &amp;ndash; we can ensure there is a reviewer beforehand This document describes motivations and a specific &amp;ldquo;early draft&amp;rdquo; proposal Motivations Proposal is to add some sort of notification / lightweight process before making major changes.</description></item><item><title>Debugging Support</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-18-debuginfo-meeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-18-debuginfo-meeting/</guid><description>Debugging Support in the Compiler Zulip stream or read on the Zulip archive The problems https://github.com/rust-lang/rust/issues/64343
We have bugs with debuginfo that are causing broad pain for people who use x.py test, but we do not have dedicated developers who own maintenance of debugger support.
https://github.com/rust-lang/rust/pull/60826
We have Pull Requests to improve our debuginfo support, but we do not have dedicated developers who own maintenance of debugger support.</description></item><item><title>Dep-graph loading (#62083)</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-11-DepGraph-persistence-PR62038/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-11-DepGraph-persistence-PR62038/</guid><description>design meeting 2019-10-11 Zulip stream
introduction Dear @T-compiler/meeting,
Today we will be having a design meeting. The topic was originally sketched as &amp;ldquo;some Zoxc PR&amp;rdquo;. We&amp;rsquo;ve since narrowed that down to discuss #62038, which is a refactoring to how dep-graph loading occurs. @Zoxc wrote up a comment giving a summary of the ideas. Note that this PR itself is an incremental step towards #60035, which aims to make dep-graph loading/saving more continuous.</description></item><item><title>Place Interning</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-27-place-interning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-27-place-interning/</guid><description>Place projection interning meeting 2019-09-27 Zulip stream
Ideas to pursue at some later point or in parallel removing the field from the projections get rid of static from PlaceBase I (oli-obk) think this would be good to pursue ealier than later since it&amp;rsquo;ll just eliminate an annoying piece that we don&amp;rsquo;t really care about most of the time intern entire places at the MIR level interning (base, Vec&amp;lt;projection&amp;gt;) means less re-use overall though nice hack: rfirst 128 (eddyb suggests 2^16) locals or so can be mapped to themselves could even be extended for whatever the most common projections are if that proves useful insert gratuitous reference to random compression methods here Ideas rejected intern the Vec&amp;lt;Projection&amp;gt; to a &amp;amp;[Projection] Rejected: List is better because it is smaller, and we can use a PlaceRef for cases where you want to do subslicing Although &amp;amp;[Projection] would mean that a.</description></item><item><title>Planning the gcx, tcx transition</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-06-21-the-gcx-tcx-transition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-06-21-the-gcx-tcx-transition/</guid><description>Planning the &#39;gcx, &#39;tcx transition Zulip thread Summary Discuss the end-state for tcx Plan the steps we will take to get there and time frame Motivation Now that we have removed the per-inference context interners, we plan to transition the compiler to a different naming scheme. This is a major shift and something we should plan carefully.
Also, it&amp;rsquo;s an opportunity to consider an alternate naming scheme &amp;ndash; tcx and &#39;tcx is not known to be particularly popular.</description></item><item><title>Read-Eval-Print-Loop (REPL) Extensions</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-29-repl-meeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-29-repl-meeting/</guid><description>Zulip stream or read on the Zulip archive. Agenda Design doc: https://hackmd.io/GJokfI0wQ0i4SIgRbFTmfw
Big picture overview and questions
Essential changes to support REPL extensions
Big picture overview of design, and on-the-fly questions about it Read (to an AST), Compile (AST to MIR), Eval (the MIR to a value), Print (the value). and Loop. Question: Is this going to be a tool analogous to miri, where check-in&amp;rsquo;s that break it may not break CI immediately, but rather will just file follow-up bugs?</description></item><item><title>Roadmap 2020</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-04-Roadmap-2020-Goals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-04-Roadmap-2020-Goals/</guid><description>Roadmap 2020 Compiler Discussion Zulip topic
2019 roadmap (for reference) The compiler team has five main themes of work for this year:
Improving &amp;ldquo;core strength&amp;rdquo; by lowering raw compilation times and also generating better code (which in turn can help with compilation times) Improved IDE integration, including support for typed completions Extracting parts of rustc into libraries, which are easier to understand and maintain but also help in developing a Rust specification Supporting lang team in key feature development, such as around async fn support, or improvements to the trait system Improving our documentation and organization, helping to make it clearer what is going on at any given time, and how people can get involved.</description></item><item><title>Target Tier Policy</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-20-target-tier-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-20-target-tier-policy/</guid><description>Target Tier Policy Zulip thread Proposal issue: rust-lang/rust#166 Original proposal with history Summary We should have an official, objective policy for adding new (tier 3) targets, and for raising targets to tier 2 (with rustup builds) or even tier 1.
Conclusion: Josh to revise policy based on feedback (done, see below) and subsequently submit as an RFC.
Motivation Rust developers regularly implement new targets in the Rust compiler, and reviewers of pull requests for such new targets would like a clear, consistent policy to cite for accepting or rejecting such targets.</description></item><item><title>Triage Working Group Discussion</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-07-08-triage-wg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-07-08-triage-wg/</guid><description>Triage Working Group Discussion Zulip thread Summary Discussed ideas of a triage working group and how that might interact Discussed pnkfelix/nikomatsakis taking leave over next few weeks and what to do in the meantime Discussed the problems around review queues pnkfelix/nikomatsakis absence pnkfelix will be going on parental leave for 2 months starting July 15. nikomatsakis will be on PTO for a month or so, with limited availability.</description></item><item><title>Unify Dataflow Frameworks (#202)</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-09-unified-dataflow-framework/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-09-unified-dataflow-framework/</guid><description>Design Meeting 2019-11-08 Zulip Stream
Agenda Design doc: https://hackmd.io/@39Qr_z9cQhasi25sGjmFnA/Skvd9rztS
Explain the current state of things
We currently have two wholly separate APIs for dataflow, one for bit-vector problems and one that allows arbitrary transfer functions but still restricts the lattice to a powerset of indices. I want to merge these two to make code more DRY. The prototype implementation is described pretty thoroughly in the design doc, but maybe go over it a bit?</description></item><item><title>Working Group Retrospective</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-16-Working-Group-Retrospective/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-16-Working-Group-Retrospective/</guid><description>Working Group Retrospective Zulip stream or read on the Zulip archive What you are looking at We did a short survey before the meeting. The following notes were scraped from the 10 responses. I tried to de-duplicate common items. Towards the end, you will find some minutes that were taken during the meeting itself. &amp;ndash;nikomatsakis
Things to KEEP doing Working groups are useful Nice to know who to talk to in order to get involved this was more of a struggle before Providing opportunities for mentorship is good Scoping out small groups of decision makers for &amp;ldquo;in the weeds&amp;rdquo; decisions Weekly updates Dedicated Zulip streams: great to have ability to link/skim, even if most are muted Regular meetings are a good way to keep working groups focused Things to STOP doing Maybe fewer working groups, with more time/energy invested in each?</description></item><item><title>rust-analyzer and libraryification</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-13-rust-analyzer-and-libraryification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-13-rust-analyzer-and-libraryification/</guid><description>rust-analyzer and libraryification Zulip thread Proposal issue: rust-lang/rust#160 Additional notes: hackmd document Summary Goal of the meeting is to update on rust-analyzer plans and discuss taking the next step towards extracting &amp;ldquo;standalone libraries&amp;rdquo; that can be shared between rustc and rust-analyzer.
Update on rust-analyzer Rust-analyzer has made big strides and now includes
name resolution a partial type checker preliminary integration with chalk for trait solving as well as a shared lexer with rustc What does library-ification mean?</description></item></channel></rss>